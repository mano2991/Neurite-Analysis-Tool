<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pyramidotomy Neurite Analysis Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 450px;
            gap: 20px;
            padding: 30px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .right-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            height: fit-content;
        }

        .upload-section {
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            background: #fafafa;
        }

        .upload-section:hover {
            border-color: #667eea;
            background: #f0f3ff;
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: #e3f2fd;
        }

        .image-container {
            position: relative;
            border: 2px solid #ddd;
            border-radius: 15px;
            overflow: hidden;
            background: #fff;
            height: 480px;
            width: 640px;
            max-width: 100%;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .analysis-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            border-radius: 10px;
            object-fit: fill;
        }

        .tools-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            border: 1px solid #eee;
        }

        .tool-group {
            margin-bottom: 20px;
        }

        .tool-group h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .tool-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
        }

        .tool-btn:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .tool-btn.active {
            background: #4c51bf;
            box-shadow: 0 4px 12px rgba(76, 81, 191, 0.3);
        }

        .tool-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .tool-btn.add { background: #1abc9c; }
        .tool-btn.add:hover { background: #16a085; }
        .tool-btn.add.active { background: #117a65; }

        .tool-btn.remove { background: #e74c3c; }
        .tool-btn.remove:hover { background: #c0392b; }
        .tool-btn.remove.active { background: #a93226; }
        
        .tool-btn.clear-auto { background: #9b59b6; }
        .tool-btn.clear-auto:hover { background: #8e44ad; }
        
        .tool-btn.exclude { background: #f39c12; }
        .tool-btn.exclude:hover { background: #e67e22; }
        .tool-btn.exclude.active { background: #d68910; }
        
        .tool-btn.area { background: #3498db; }
        .tool-btn.area:hover { background: #2980b9; }
        .tool-btn.area.active { background: #2471a3; }
        
        .tool-btn.clear { background: #e67e22; }
        .tool-btn.clear:hover { background: #d35400; }
        
        .tool-btn.newimage { background: #34495e; }
        .tool-btn.newimage:hover { background: #2c3e50; }

        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50; }
        .input-group input, .input-group select { width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px; transition: border-color 0.3s ease; }
        .input-group input:focus, .input-group select:focus { outline: none; border-color: #667eea; }
        .slider-group { margin-bottom: 15px; }
        .slider-group label { display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50; font-size: 12px; }
        .slider-container { display: flex; align-items: center; gap: 10px; }
        .slider { flex: 1; height: 4px; border-radius: 2px; background: #ddd; outline: none; -webkit-appearance: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #667eea; cursor: pointer; }
        .slider::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #667eea; cursor: pointer; border: none; }
        .slider-value { min-width: 35px; font-size: 12px; color: #666; }
        .side-selection-hint { background: #e8f4fd; padding: 20px; border-radius: 15px; margin-bottom: 20px; border: 2px solid #3498db; text-align: center; }
        .side-selection-hint h3 { color: #2c3e50; margin-bottom: 10px; }
        .side-selection-hint p { color: #666; font-size: 14px; }
        .regeneration-display { background: linear-gradient(135deg, #27ae60, #2ecc71); color: white; padding: 20px; border-radius: 15px; margin-bottom: 20px; text-align: center; }
        .regen-percentage { font-size: 2.5em; font-weight: bold; margin-bottom: 5px; }
        .regen-label { font-size: 1.1em; opacity: 0.9; }
        .regen-details { font-size: 0.9em; margin-top: 10px; opacity: 0.8; }
        .neurite-counter { display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 15px; }
        .counter-group { padding: 8px; border: 1px solid #ddd; border-radius: 6px; background: white; display: flex; justify-content: space-between; align-items: center; }
        .counter-label { font-size: 11px; font-weight: 600; color: #666; }
        .counter-display { font-size: 14px; font-weight: bold; color: #2c3e50; min-width: 30px; text-align: center; }
        .results-section { margin-top: 30px; padding: 25px; background: white; border-radius: 15px; border: 1px solid #eee; }
        .chart-container { height: 300px; margin: 20px 0; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px; }
        .stat-card { padding: 20px; border-radius: 10px; text-align: center; color: white; }
        .stat-card.regenerative { background: linear-gradient(135deg, #27ae60, #2ecc71); }
        .stat-card.total { background: linear-gradient(135deg, #3498db, #5dade2); }
        .stat-card.longest { background: linear-gradient(135deg, #e74c3c, #ec7063); }
        .stat-value { font-size: 2em; font-weight: bold; margin-bottom: 5px; }
        .stat-label { font-size: 0.9em; opacity: 0.9; }
        .image-info { background: #e8f4fd; padding: 15px; border-radius: 10px; margin-bottom: 20px; }
        .analyze-btn { width: 100%; padding: 15px; background: linear-gradient(135deg, #27ae60, #2ecc71); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; margin-bottom: 10px; }
        .analyze-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(39, 174, 96, 0.3); }
        .analyze-btn:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; box-shadow: none; }
        .export-btn { width: 100%; padding: 15px; background: linear-gradient(135deg, #3498db, #5dade2); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; }
        .export-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3); }
        .export-btn:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; box-shadow: none; }
        .processing-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; border-radius: 15px; }
        .status-bar { background: #2c3e50; color: white; padding: 10px 20px; border-radius: 8px; margin-bottom: 15px; font-size: 14px; }
        .progress-bar { width: 100%; height: 4px; background: #ddd; border-radius: 2px; overflow: hidden; margin-top: 10px; }
        .progress-fill { height: 100%; background: #27ae60; transition: width 0.3s ease; width: 0%; }
        .detailed-results { margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px; }
        .result-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .result-table th, .result-table td { padding: 10px; text-align: center; border: 1px solid #ddd; }
        .result-table th { background: #3498db; color: white; font-weight: bold; }
        .result-table td { background: white; }
        .exclusion-mode-selector { display: flex; gap: 10px; margin-bottom: 15px; }
        .mode-btn { padding: 8px 16px; border: 2px solid #e74c3c; background: white; color: #e74c3c; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.3s ease; }
        .mode-btn.active { background: #e74c3c; color: white; }
        .new-image-button-container { position: relative; z-index: 10; margin-bottom: 10px; }

        /* TIFF Modal Styles */
        .tiff-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease;
        }

        .tiff-modal-content {
            background: white;
            border-radius: 20px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        .tiff-header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tiff-header h2 {
            margin: 0;
            font-size: 1.5em;
        }

        .close-modal {
            background: none;
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .close-modal:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .tiff-body {
            padding: 30px;
        }

        .file-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid #e9ecef;
        }

        .file-info p {
            margin: 5px 0;
            font-size: 14px;
        }

        .tiff-body h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .conversion-methods {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 25px;
        }

        .method-card {
            border: 2px solid #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .method-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.1);
        }

        .method-card.recommended {
            border-color: #27ae60;
            background: linear-gradient(135deg, #d5f4e6 0%, #f0f9f5 100%);
        }

        .method-card.recommended:hover {
            border-color: #219a52;
        }

        .method-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .method-card.recommended .method-header {
            background: #27ae60;
            color: white;
        }

        .method-header h4 {
            margin: 0;
            font-size: 1.1em;
        }

        .method-content {
            padding: 20px;
        }

        .method-content ul, .method-content ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .method-content li {
            margin: 8px 0;
            line-height: 1.4;
        }

        .method-content a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .method-content a:hover {
            text-decoration: underline;
        }

        .pro-tips {
            background: #e8f4fd;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #3498db;
            margin-bottom: 25px;
        }

        .pro-tips h4 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .pro-tips ul {
            margin: 0;
            padding-left: 20px;
        }

        .pro-tips li {
            margin: 8px 0;
            line-height: 1.4;
        }

        .modal-actions {
            text-align: center;
        }

        .action-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .action-btn.primary {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        .action-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.3);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @media (max-width: 1200px) { .main-content { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Pyramidotomy Neurite Analysis Tool</h1>
            <p>Advanced neurite detection and measurement with distance-based analysis</p>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="upload-section" id="uploadSection">
                    <div id="uploadPrompt">
                        <h3>Upload Pyramidotomy Image</h3>
                        <p>Drag and drop a PNG/JPG/TIFF image here or click to select</p>
                        <input type="file" id="imageInput" accept=".png,.jpg,.jpeg,.tif,.tiff" style="display: none;">
                        <button class="tool-btn" onclick="document.getElementById('imageInput').click()">Choose Image</button>
                    </div>
                </div>

                <div class="new-image-button-container" id="newImageButtonContainer" style="display: none;">
                    <input type="file" id="newImageInput" accept=".png,.jpg,.jpeg,.tif,.tiff" style="display: none;">
                    <button class="tool-btn newimage" onclick="document.getElementById('newImageInput').click()" style="width: 100%;">📷 Upload New Image</button>
                </div>

                <div class="image-container" id="imageContainer" style="display: none;">
                    <canvas id="analysisCanvas" class="analysis-canvas"></canvas>
                    <div class="processing-overlay" id="processingOverlay" style="display: none;">
                        <div>
                            <div>Processing image...</div>
                            <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                        </div>
                    </div>
                </div>

                <div class="tools-section" id="toolsSection" style="display: none;">
                    <div class="status-bar" id="statusBar">Click "Draw Midline" and draw a line to separate left and right sides</div>

                    <div class="tool-group">
                        <h3>Analysis Steps</h3>
                        <div class="tool-buttons">
                            <button class="tool-btn active" id="midlineBtn" onclick="setTool('midline')">1. Midline</button>
                            <button class="tool-btn" id="selectSideBtn" onclick="setTool('selectSide')" disabled>2. Select Side</button>
                            <button class="tool-btn area" id="areaBtn" onclick="setTool('area')" disabled>3. Analysis Area</button>
                            <button class="tool-btn exclude" id="excludeBtn" onclick="setTool('exclude')" disabled>4. Exclude Zones</button>
                            <button class="tool-btn" id="detectBtn" onclick="setTool('detect')" disabled>5. Auto-Detect</button>
                            <button class="tool-btn add" id="addBtn" onclick="setTool('add')" disabled>6. Add Neurite</button>
                            <button class="tool-btn remove" id="removeBtn" onclick="setTool('remove')" disabled>7. Remove Neurite</button>
                            <button class="tool-btn clear-auto" id="clearAutoBtn" onclick="clearAutoDetected()" disabled>Clear Auto</button>
                            <button class="tool-btn clear" onclick="clearCanvas()">Clear All</button>
                        </div>
                    </div>

                    <div class="tool-group" id="exclusionModeGroup" style="display: none;">
                        <h3>Exclusion Zone Mode</h3>
                        <div class="exclusion-mode-selector">
                            <button class="mode-btn" id="rectangleMode" onclick="setExclusionMode('rectangle')">Rectangle</button>
                            <button class="mode-btn active" id="freeformMode" onclick="setExclusionMode('freeform')">Free-form</button>
                        </div>
                    </div>

                    <div class="tool-group">
                        <h3>Image Adjustments</h3>
                        <div class="slider-group">
                            <label>Brightness:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="brightnessSlider" min="0" max="200" value="100" step="1">
                                <span class="slider-value" id="brightnessValue">100%</span>
                            </div>
                        </div>
                        <div class="slider-group">
                            <label>Contrast:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="contrastSlider" min="0" max="200" value="100" step="1">
                                <span class="slider-value" id="contrastValue">100%</span>
                            </div>
                        </div>
                    </div>

                    <div class="tool-group">
                        <h3>Detection Settings</h3>
                        <div class="input-group">
                            <label>Scale (pixels per μm):</label>
                            <input type="number" id="scaleInput" value="0.5" step="0.1" placeholder="Enter scale factor">
                        </div>
                        <div class="input-group">
                            <label>Sensitivity:</label>
                            <select id="sensitivitySelect">
                                <option value="low">Low</option>
                                <option value="medium" selected>Medium</option>
                                <option value="high">High</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>Minimum Neurite Length (μm):</label>
                            <input type="number" id="minLengthInput" value="5" min="1" step="1">
                        </div>
                        <div class="input-group">
                            <label>Detection Threshold:</label>
                            <input type="number" id="detectionThreshold" value="100" min="50" max="255" step="5">
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="image-info" id="imageInfo" style="display: none;">
                    <h3>Image Information</h3>
                    <p id="imageDetails"></p>
                </div>

                <div class="side-selection-hint" id="sideSelectionHint" style="display: none;">
                    <h3>Select Side to Analyze</h3>
                    <p>Click on the side of the image you want to analyze for neurite growth.</p>
                </div>

                <div class="regeneration-display" id="regenDisplay" style="display: none;">
                    <div class="regen-percentage" id="mainRegenPercentage">0%</div>
                    <div class="regen-label">Total Neurites on Selected Side</div>
                    <div class="regen-details" id="regenDetails"></div>
                </div>

                <h3>Detected Neurites by Distance</h3>
                
                <h4 id="sideLabel">Selected Side</h4>
                <div class="neurite-counter">
                    <div class="counter-group">
                        <div class="counter-label">0-200 μm</div>
                        <div class="counter-display" id="count_0_200">0</div>
                    </div>
                    <div class="counter-group">
                        <div class="counter-label">200-400 μm</div>
                        <div class="counter-display" id="count_200_400">0</div>
                    </div>
                    <div class="counter-group">
                        <div class="counter-label">400-600 μm</div>
                        <div class="counter-display" id="count_400_600">0</div>
                    </div>
                    <div class="counter-group">
                        <div class="counter-label">600-800 μm</div>
                        <div class="counter-display" id="count_600_800">0</div>
                    </div>
                    <div class="counter-group">
                        <div class="counter-label">>800 μm</div>
                        <div class="counter-display" id="count_800_plus">0</div>
                    </div>
                </div>

                <button class="analyze-btn" id="analyzeBtn" onclick="analyzeResults(true)" disabled>Generate Analysis Report</button>
                <button class="export-btn" id="exportBtn" onclick="exportToCSV()" disabled>Export Data to CSV</button>
                <button class="export-btn" id="saveImageBtn" onclick="saveNeuriteImage()" disabled style="margin-top: 10px;">Save Labeled Image</button>
            </div>
        </div>

        <!-- TIFF Conversion Modal -->
        <div class="tiff-modal" id="tiffModal" style="display: none;">
            <div class="tiff-modal-content">
                <div class="tiff-header">
                    <h2>📁 TIFF File Detected</h2>
                    <button class="close-modal" onclick="closeTiffModal()">&times;</button>
                </div>
                <div class="tiff-body">
                    <div class="file-info">
                        <p><strong>📁 Your File:</strong></p>
                        <p><strong>Name:</strong> <span id="tiffFileName">filename.tif</span></p>
                        <p><strong>Size:</strong> <span id="tiffFileSize">0 MB</span></p>
                        <p><strong>Format:</strong> TIFF/TIF</p>
                    </div>
                    
                    <h3>🎯 Choose Your Conversion Method</h3>
                    
                    <div class="conversion-methods">
                        <div class="method-card recommended">
                            <div class="method-header">
                                <h4>🥇 ImageJ/Fiji (Recommended for Scientific Images)</h4>
                            </div>
                            <div class="method-content">
                                <p><strong>Why ImageJ is perfect for your neurite analysis:</strong></p>
                                <ul>
                                    <li>Designed specifically for scientific images</li>
                                    <li>Preserves image quality and metadata</li>
                                    <li>Handles complex TIFF formats (16-bit, multi-channel, etc.)</li>
                                    <li>Free and widely used in neuroscience research</li>
                                </ul>
                                <p><strong>Quick Steps:</strong></p>
                                <ol>
                                    <li>Download: <a href="https://imagej.nih.gov/ij/download.html" target="_blank">imagej.nih.gov/ij/download.html</a></li>
                                    <li>Open ImageJ → File → Open → Select your TIFF</li>
                                    <li>If needed: Image → Type → 8-bit</li>
                                    <li>File → Save As → PNG</li>
                                </ol>
                            </div>
                        </div>
                        
                        <div class="method-card">
                            <div class="method-header">
                                <h4>🌐 Online Converter (Quick & Easy)</h4>
                            </div>
                            <div class="method-content">
                                <p><strong>Perfect for quick conversions:</strong></p>
                                <ul>
                                    <li>No software installation required</li>
                                    <li>Works on any device with internet</li>
                                    <li>Usually handles standard TIFF formats well</li>
                                </ul>
                                <p><strong>Recommended Sites:</strong></p>
                                <ul>
                                    <li><a href="https://convertio.co/tiff-png" target="_blank">convertio.co/tiff-png</a></li>
                                    <li><a href="https://cloudconvert.com/tiff-to-png" target="_blank">cloudconvert.com/tiff-to-png</a></li>
                                    <li><a href="https://zamzar.com/convert/tiff-to-png" target="_blank">zamzar.com/convert/tiff-to-png</a></li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="method-card">
                            <div class="method-header">
                                <h4>🎨 GIMP (Free Graphics Software)</h4>
                            </div>
                            <div class="method-content">
                                <p><strong>Good for general image editing:</strong></p>
                                <ul>
                                    <li>Free alternative to Photoshop</li>
                                    <li>Handles most TIFF formats</li>
                                    <li>Additional image editing capabilities</li>
                                </ul>
                                <p><strong>Steps:</strong></p>
                                <ol>
                                    <li>Download: <a href="https://gimp.org/downloads" target="_blank">gimp.org/downloads</a></li>
                                    <li>Open GIMP → File → Open → Select your TIFF</li>
                                    <li>If needed: Image → Mode → RGB</li>
                                    <li>File → Export As → Choose PNG format</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    
                    <div class="pro-tips">
                        <h4>💡 Pro Tips for Best Results:</h4>
                        <ul>
                            <li><strong>Preserve Quality:</strong> Choose PNG format (lossless compression)</li>
                            <li><strong>For Scientific Images:</strong> Use ImageJ - it's designed for your workflow</li>
                            <li><strong>Check Image Depth:</strong> Convert to 8-bit if your TIFF is 16-bit</li>
                            <li><strong>Maintain Scale:</strong> Note any scale information from your microscope</li>
                        </ul>
                    </div>
                    
                    <div class="modal-actions">
                        <button class="action-btn primary" onclick="closeTiffModal()">✅ Got it! I'll convert my TIFF file</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="results-section" id="resultsSection" style="display: none;">
            <h2>Analysis Results</h2>
            <div class="chart-container"><canvas id="comparisonChart"></canvas></div>
            <div class="stats-grid">
                <div class="stat-card total"><div class="stat-value" id="totalNeurites">0</div><div class="stat-label">Total Neurites</div></div>
                <div class="stat-card longest"><div class="stat-value" id="longestNeurite">0 μm</div><div class="stat-label">Longest Neurite</div></div>
                <div class="stat-card regenerative"><div class="stat-value" id="averageLength">0 μm</div><div class="stat-label">Average Length</div></div>
            </div>
            <div class="detailed-results" id="detailedResults"></div>
        </div>
    </div>

    <script>
        let canvas, ctx;
        let originalImage = null;
        let adjustedCanvas = null;
        let currentTool = 'midline';
        let midline = null;
        let analysisArea = null;
        let exclusionZones = [];
        let exclusionMode = 'freeform';
        let currentFreeformZone = [];
        let detectedNeurites = [];
        let isDrawing = false;
        let currentExclusionZone = null;
        let currentAreaPoints = [];
        let newNeuriteStartPoint = null;
        let scale = 0.5;
        let selectedSide = null;
        let brightness = 100;
        let contrast = 100;

        function initializeApp() {
            canvas = document.getElementById('analysisCanvas');
            ctx = canvas.getContext('2d', { willReadFrequently: true });
            setupEventListeners();
            updateStatus("Ready to analyze. Upload an image to begin.");
        }

        function setupEventListeners() {
            const imageInput = document.getElementById('imageInput');
            const uploadSection = document.getElementById('uploadSection');
            imageInput.addEventListener('change', handleImageUpload);
            const newImageInput = document.getElementById('newImageInput');
            newImageInput.addEventListener('change', handleNewImageUpload);
            
            uploadSection.addEventListener('dragover', (e) => { e.preventDefault(); uploadSection.classList.add('dragover'); });
            uploadSection.addEventListener('dragleave', () => { uploadSection.classList.remove('dragover'); });
            uploadSection.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadSection.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) handleImageFile(e.dataTransfer.files[0]);
            });

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('dblclick', handleCanvasDoubleClick);
            setupSliders();
            document.getElementById('scaleInput').addEventListener('change', (e) => {
                scale = parseFloat(e.target.value) || 0.5;
                if (detectedNeurites.length > 0) updateAllResults();
            });
        }

        function setupSliders() {
            const brightnessSlider = document.getElementById('brightnessSlider');
            const contrastSlider = document.getElementById('contrastSlider');
            brightnessSlider.addEventListener('input', (e) => {
                brightness = parseInt(e.target.value);
                document.getElementById('brightnessValue').textContent = brightness + '%';
                applyImageAdjustments();
            });
            contrastSlider.addEventListener('input', (e) => {
                contrast = parseInt(e.target.value);
                document.getElementById('contrastValue').textContent = contrast + '%';
                applyImageAdjustments();
            });
        }

        function applyImageAdjustments() {
            if (!originalImage) return;
            if (!adjustedCanvas) adjustedCanvas = document.createElement('canvas');
            adjustedCanvas.width = canvas.width;
            adjustedCanvas.height = canvas.height;
            const adjustedCtx = adjustedCanvas.getContext('2d', { willReadFrequently: true });
            adjustedCtx.filter = `brightness(${brightness}%) contrast(${contrast}%)`;
            adjustedCtx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            adjustedCtx.filter = 'none';
            redrawCanvas();
        }

        function handleImageUpload(e) { handleImageFile(e.target.files[0]); }
        function handleNewImageUpload(e) {
            if (e.target.files[0]) {
                resetAnalysis();
                handleImageFile(e.target.files[0]);
            }
        }

        function handleImageFile(file) {
            if (!file) return;
            
            // Check if the file is a TIFF
            if (file.type === 'image/tiff' || file.type === 'image/tif' || 
                file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')) {
                showTiffModal(file);
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                originalImage = new Image();
                originalImage.onload = () => {
                    setupCanvas(originalImage);
                    displayImageInfo(originalImage, file);
                    resetAnalysis();
                    applyImageAdjustments();
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas(img) {
            canvas.width = 640;
            canvas.height = 480;
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('newImageButtonContainer').style.display = 'block';
            document.getElementById('imageContainer').style.display = 'flex';
            document.getElementById('toolsSection').style.display = 'block';
            updateStatus("Step 1: Draw a midline.");
        }

        function displayImageInfo(img, file) {
            document.getElementById('imageDetails').innerHTML = `
                <strong>File:</strong> ${file.name}<br>
                <strong>Size:</strong> ${img.width} × ${img.height} px<br>
                <strong>File Size:</strong> ${(file.size / 1024).toFixed(1)} KB`;
            document.getElementById('imageInfo').style.display = 'block';
        }

        function resetAnalysis() {
            midline = null; analysisArea = null; exclusionZones = [];
            currentFreeformZone = []; currentAreaPoints = []; detectedNeurites = [];
            currentExclusionZone = null; selectedSide = null; newNeuriteStartPoint = null;
            
            ['midlineBtn', 'selectSideBtn', 'areaBtn', 'excludeBtn', 'detectBtn', 'addBtn', 'removeBtn', 'clearAutoBtn', 'analyzeBtn', 'exportBtn', 'saveImageBtn'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.disabled = id !== 'midlineBtn';
                    btn.classList.remove('active');
                }
            });
            document.getElementById('midlineBtn').classList.add('active');
            
            ['exclusionModeGroup', 'sideSelectionHint', 'regenDisplay', 'resultsSection'].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            document.getElementById('sideLabel').textContent = 'Selected Side';
            resetCounters();
            setTool('midline');
        }

        function setTool(tool) {
            currentTool = tool;
            newNeuriteStartPoint = null;
            
            if(tool === 'detect') {
                detectNeurites();
                return;
            }

            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            if (document.getElementById(tool + 'Btn')) {
                document.getElementById(tool + 'Btn').classList.add('active');
            }

            document.getElementById('exclusionModeGroup').style.display = tool === 'exclude' ? 'block' : 'none';
            document.getElementById('sideSelectionHint').style.display = tool === 'selectSide' ? 'block' : 'none';
            
            let status = "", cursor = "default";
            switch(tool) {
                case 'midline':    status = "Click and drag to draw a midline."; cursor = "crosshair"; break;
                case 'selectSide': status = "Click on the side to analyze."; cursor = "pointer"; break;
                case 'area':       status = "Click points to define analysis area (double-click to finish)."; cursor = "crosshair"; break;
                case 'exclude':    status = `Draw ${exclusionMode} exclusion zones.`; cursor = "crosshair"; break;
                case 'add':        status = "Click a start point, then an end point to add a new neurite."; cursor = "cell"; break;
                case 'remove':     status = "Click near a neurite's endpoint to remove it."; cursor = "pointer"; break;
            }
            updateStatus(status);
            canvas.style.cursor = cursor;
        }

        function setExclusionMode(mode) {
            exclusionMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode + 'Mode').classList.add('active');
            if (currentTool === 'exclude') setTool('exclude');
        }

        function startDrawing(e) {
            if (currentTool !== 'midline' && (currentTool !== 'exclude' || exclusionMode !== 'rectangle')) return;
            isDrawing = true;
            const pos = getMousePos(e);
            if (currentTool === 'midline') {
                midline = [pos];
            } else {
                currentExclusionZone = { type: 'rectangle', startX: pos.x, startY: pos.y, endX: pos.x, endY: pos.y };
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            const pos = getMousePos(e);
            redrawCanvas();
            if (currentTool === 'midline' && midline && midline.length === 1) {
                drawTempLine(midline[0], pos, '#9b59b6', 3);
            } else if (currentTool === 'exclude' && exclusionMode === 'rectangle' && currentExclusionZone) {
                currentExclusionZone.endX = pos.x;
                currentExclusionZone.endY = pos.y;
                drawTempExclusionZone(currentExclusionZone);
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            const pos = getMousePos(e);
            if (currentTool === 'midline' && midline && midline.length === 1) {
                midline.push(pos);
                document.getElementById('selectSideBtn').disabled = false;
                setTool('selectSide');
            } else if (currentTool === 'exclude' && exclusionMode === 'rectangle' && currentExclusionZone) {
                currentExclusionZone.endX = pos.x;
                currentExclusionZone.endY = pos.y;
                if (Math.abs(currentExclusionZone.endX - currentExclusionZone.startX) > 10 && Math.abs(currentExclusionZone.endY - currentExclusionZone.startY) > 10) {
                    exclusionZones.push({...currentExclusionZone});
                }
                currentExclusionZone = null;
            }
            redrawCanvas();
        }

        function handleCanvasClick(e) {
            const pos = getMousePos(e);
            switch(currentTool) {
                case 'selectSide':
                    selectedSide = isLeftSide(pos) ? 'left' : 'right';
                    document.getElementById('sideLabel').textContent = `${selectedSide.charAt(0).toUpperCase() + selectedSide.slice(1)} Side`;
                    document.getElementById('areaBtn').disabled = false;
                    setTool('area');
                    break;
                case 'area':
                    currentAreaPoints.push(pos);
                    redrawCanvas();
                    break;
                case 'exclude':
                    if (exclusionMode === 'freeform') {
                        currentFreeformZone.push(pos);
                        redrawCanvas();
                    }
                    break;
                case 'remove':
                    const neuriteToRemove = findNeuriteNearPoint(pos);
                    if (neuriteToRemove && confirm('Are you sure you want to delete this neurite?')) {
                        detectedNeurites = detectedNeurites.filter(n => n !== neuriteToRemove);
                        updateAllResults();
                    }
                    break;
                case 'add':
                    if (!midline) {
                        alert("Please draw a midline first before adding neurites.");
                        return;
                    }
                    if (!newNeuriteStartPoint) {
                        newNeuriteStartPoint = pos;
                        updateStatus("Start point selected. Click again to set the end point.");
                        redrawCanvas();
                    } else {
                        const newNeurite = {
                            startpoint: newNeuriteStartPoint,
                            endpoint: pos,
                            path: [newNeuriteStartPoint, pos],
                            manual: true,
                            length: Math.hypot(pos.x - newNeuriteStartPoint.x, pos.y - newNeuriteStartPoint.y) / scale,
                            distanceFromMidline: calculateDistanceFromMidline(pos)
                        };
                        detectedNeurites.push(newNeurite);
                        newNeuriteStartPoint = null;
                        updateAllResults();
                        setTool('add');
                    }
                    break;
            }
        }

        function handleCanvasDoubleClick(e) {
            if (currentTool === 'area' && currentAreaPoints.length >= 3) {
                analysisArea = { type: 'polygon', points: [...currentAreaPoints] };
                currentAreaPoints = [];
                document.getElementById('excludeBtn').disabled = false;
                document.getElementById('detectBtn').disabled = false;
                setTool('exclude');
            } else if (currentTool === 'exclude' && exclusionMode === 'freeform' && currentFreeformZone.length >= 3) {
                exclusionZones.push({ type: 'freeform', points: [...currentFreeformZone] });
                currentFreeformZone = [];
            }
            redrawCanvas();
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }
        
        function findNeuriteNearPoint(point) {
            const clickRadius = 10;
            return detectedNeurites.find(neurite => Math.hypot(neurite.endpoint.x - point.x, neurite.endpoint.y - point.y) < clickRadius);
        }

        function drawTempLine(start, end, color, width) {
            ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.setLineDash([5, 5]);
            ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); ctx.stroke();
            ctx.restore();
        }

        function drawTempExclusionZone(zone) {
            ctx.save(); ctx.strokeStyle = '#ff0000'; ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
            ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
            const x = Math.min(zone.startX, zone.endX), y = Math.min(zone.startY, zone.endY);
            const w = Math.abs(zone.endX - zone.startX), h = Math.abs(zone.endY - zone.startY);
            ctx.fillRect(x, y, w, h); ctx.strokeRect(x, y, w, h);
            ctx.restore();
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (adjustedCanvas) ctx.drawImage(adjustedCanvas, 0, 0);
            else if (originalImage) ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

            if (midline && midline.length === 2) drawDistanceLines();
            
            if (midline && midline.length === 2) {
                ctx.save(); ctx.strokeStyle = '#9b59b6'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(midline[0].x, midline[0].y); ctx.lineTo(midline[1].x, midline[1].y); ctx.stroke();
                ctx.restore();
            }

            if (analysisArea && analysisArea.points) {
                ctx.save(); ctx.strokeStyle = '#FFD700'; ctx.fillStyle = 'rgba(255, 215, 0, 0.2)'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(analysisArea.points[0].x, analysisArea.points[0].y);
                for (let i = 1; i < analysisArea.points.length; i++) ctx.lineTo(analysisArea.points[i].x, analysisArea.points[i].y);
                ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.restore();
            }

            if (currentAreaPoints.length > 0) {
                if (currentAreaPoints.length > 1) {
                    ctx.save(); ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                    ctx.beginPath(); ctx.moveTo(currentAreaPoints[0].x, currentAreaPoints[0].y);
                    for (let i = 1; i < currentAreaPoints.length; i++) ctx.lineTo(currentAreaPoints[i].x, currentAreaPoints[i].y);
                    ctx.stroke(); ctx.restore();
                }
                currentAreaPoints.forEach(p => { ctx.save(); ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI); ctx.fill(); ctx.restore(); });
            }
            
            if (currentFreeformZone.length > 0) {
                if (currentFreeformZone.length > 1) {
                    ctx.save(); ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                    ctx.beginPath(); ctx.moveTo(currentFreeformZone[0].x, currentFreeformZone[0].y);
                    for (let i = 1; i < currentFreeformZone.length; i++) ctx.lineTo(currentFreeformZone[i].x, currentFreeformZone[i].y);
                    ctx.stroke(); ctx.restore();
                }
                currentFreeformZone.forEach(p => { ctx.save(); ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI); ctx.fill(); ctx.restore(); });
            }

            exclusionZones.forEach(zone => {
                ctx.save(); ctx.strokeStyle = '#ff0000'; ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; ctx.lineWidth = 2;
                if (zone.type === 'rectangle') {
                    const x = Math.min(zone.startX, zone.endX), y = Math.min(zone.startY, zone.endY);
                    const w = Math.abs(zone.endX - zone.startX), h = Math.abs(zone.endY - zone.startY);
                    ctx.fillRect(x, y, w, h); ctx.strokeRect(x, y, w, h);
                } else if (zone.type === 'freeform' && zone.points.length >= 3) {
                    ctx.beginPath(); ctx.moveTo(zone.points[0].x, zone.points[0].y);
                    for (let i = 1; i < zone.points.length; i++) ctx.lineTo(zone.points[i].x, zone.points[i].y);
                    ctx.closePath(); ctx.fill(); ctx.stroke();
                }
                ctx.restore();
            });
            
            if (newNeuriteStartPoint) {
                ctx.save(); ctx.fillStyle = '#1abc9c'; ctx.beginPath();
                ctx.arc(newNeuriteStartPoint.x, newNeuriteStartPoint.y, 5, 0, 2 * Math.PI);
                ctx.fill(); ctx.restore();
            }
            
            drawDetectedNeurites();
        }

        function drawDistanceLines() {
            if (!midline || midline.length !== 2) return;
            const distances = [200, 400, 600, 800];
            const colors = ['#00FF00', '#FFFF00', '#FF8C00', '#FF4500'];
            const [p1, p2] = midline;
            const midLength = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            if (midLength === 0) return;
            const perpX = -(p2.y - p1.y) / midLength, perpY = (p2.x - p1.x) / midLength;
            const midX = (p1.x + p2.x) / 2, midY = (p1.y + p2.y) / 2;
            
            distances.forEach((distance, index) => {
                const pixelDistance = distance * scale;
                [-1, 1].forEach(side => {
                    const sideX = midX + pixelDistance * perpX * side;
                    const sideY = midY + pixelDistance * perpY * side;
                    const lineVecX = (p2.x - p1.x) / midLength;
                    const lineVecY = (p2.y - p1.y) / midLength;
                    const extensionLength = Math.max(canvas.width, canvas.height);
                    
                    const lineStartX = sideX - extensionLength * lineVecX;
                    const lineStartY = sideY - extensionLength * lineVecY;
                    const lineEndX = sideX + extensionLength * lineVecX;
                    const lineEndY = sideY + extensionLength * lineVecY;
                    
                    ctx.save();
                    ctx.strokeStyle = colors[index]; ctx.lineWidth = 2; ctx.setLineDash([8, 4]);
                    ctx.beginPath(); ctx.moveTo(lineStartX, lineStartY); ctx.lineTo(lineEndX, lineEndY); ctx.stroke();
                    ctx.fillStyle = colors[index]; ctx.font = 'bold 12px Arial'; ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 3;
                    ctx.strokeText(`${distance}μm`, sideX + 5, sideY - 5);
                    ctx.fillText(`${distance}μm`, sideX + 5, sideY - 5);
                    ctx.restore();
                });
            });
        }
        
        function drawDetectedNeurites() {
            detectedNeurites.forEach((neurite) => {
                let color = '#00FF00';
                if (neurite.distanceFromMidline > 200) color = '#FFFF00';
                if (neurite.distanceFromMidline > 400) color = '#FF8C00';
                if (neurite.distanceFromMidline > 600) color = '#FF4500';
                if (neurite.distanceFromMidline > 800) color = '#FF0000';
                
                ctx.save();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(neurite.startpoint.x, neurite.startpoint.y);
                ctx.lineTo(neurite.endpoint.x, neurite.endpoint.y);
                ctx.stroke();
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(neurite.endpoint.x, neurite.endpoint.y, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
            });
        }

        function isLeftSide(point) { if (!midline || midline.length !== 2) return false; const [p1, p2] = midline; return (p2.x - p1.x) * (point.y - p1.y) - (p2.y - p1.y) * (point.x - p1.x) > 0; }
        function isPointInPolygon(point, polygon) { let inside = false; for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) { if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) && (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) inside = !inside; } return inside; }
        function isPointInExclusionZone(point) { for (let zone of exclusionZones) { if (zone.type === 'rectangle') { const minX = Math.min(zone.startX, zone.endX), maxX = Math.max(zone.startX, zone.endX), minY = Math.min(zone.startY, zone.endY), maxY = Math.max(zone.startY, zone.endY); if (point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY) return true; } else if (zone.type === 'freeform') { if (isPointInPolygon(point, zone.points)) return true; } } return false; }
        function isPointInAnalysisArea(point) { if (!analysisArea || !analysisArea.points) return false; return isPointInPolygon(point, analysisArea.points); }

        function performNeuriteDetection() {
            try {
                const imageData = adjustedCanvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                const sensitivity = document.getElementById('sensitivitySelect').value;
                detectedNeurites = analyzeImageForNeurites(imageData, sensitivity);
                
                ['addBtn', 'removeBtn', 'clearAutoBtn', 'analyzeBtn', 'exportBtn', 'saveImageBtn'].forEach(id => document.getElementById(id).disabled = false);
                setTool('add');
                updateAllResults();
                updateStatus(`Detection complete! Found ${detectedNeurites.length} neurites.`);
            } catch (error) {
                console.error("Detection Error:", error);
                updateStatus("An error occurred during detection. See console for details.");
            } finally {
                showProcessing(false);
            }
        }
        
        function detectNeurites() {
            if (!analysisArea || !midline || !selectedSide) return updateStatus("Please complete all setup steps first");
            showProcessing(true);
            updateStatus("Scanning for neurites...");
            setTimeout(performNeuriteDetection, 50);
        }
        
        function updateAllResults() {
            detectedNeurites.forEach(n => n.distanceFromMidline = calculateDistanceFromMidline(n.endpoint));
            redrawCanvas();
            categorizeNeurites();
            updateRegenerationDisplay();
            analyzeResults(false);
        }

        function clearAutoDetected() {
            if(confirm("This will remove all auto-detected neurites, keeping only the ones you added manually. Are you sure?")) {
                detectedNeurites = detectedNeurites.filter(n => n.manual);
                updateAllResults();
            }
        }

        function analyzeImageForNeurites(imageData, sensitivity) { const neurites = []; const { data, width, height } = imageData; const threshold = parseFloat(document.getElementById('detectionThreshold').value) || 100; const minLength = parseFloat(document.getElementById('minLengthInput').value) || 5; const thresholdAdjustments = { 'low': 40, 'medium': 0, 'high': -30 }; const adjustedThreshold = threshold + thresholdAdjustments[sensitivity]; const startingPoints = findNeuriteStartingPoints(data, width, height, adjustedThreshold); startingPoints.forEach(startPoint => { const traces = traceNeuritesFromPoint(data, width, height, startPoint, adjustedThreshold, minLength); neurites.push(...traces); }); return neurites; }
        function findNeuriteStartingPoints(data, width, height, threshold) { const startingPoints = []; if (!midline || midline.length !== 2) return startingPoints; const distance = Math.hypot(midline[1].x - midline[0].x, midline[1].y - midline[0].y); const steps = Math.floor(distance / 2); for (let i = 0; i <= steps; i++) { const t = i / steps; const x = Math.round(midline[0].x + t * (midline[1].x - midline[0].x)); const y = Math.round(midline[0].y + t * (midline[1].y - midline[0].y)); if (x >= 0 && x < width && y >= 0 && y < height) { const point = {x, y}; if (isPointInAnalysisArea(point) && !isPointInExclusionZone(point)) { const brightness = (data[(y * width + x) * 4] + data[(y * width + x) * 4 + 1] + data[(y * width + x) * 4 + 2]) / 3; if (brightness > threshold) startingPoints.push({x, y, brightness}); } } } return startingPoints.sort((a, b) => b.brightness - a.brightness).slice(0, 150); }
        function traceNeuritesFromPoint(data, width, height, startPoint, threshold, minLength) { const neurites = []; for (let dir = 0; dir < 16; dir++) { const angle = (dir * Math.PI * 2) / 16; const cosAngle = Math.cos(angle); const sinAngle = Math.sin(angle); if ((isLeftSide({x: startPoint.x + 20 * cosAngle, y: startPoint.y + 20 * sinAngle}) ? 'left' : 'right') !== selectedSide) continue; let path = [{x: startPoint.x, y: startPoint.y}]; let consecutiveDarkPixels = 0; const maxDarkPixels = 12; for (let dist = 1; dist < 800; dist++) { const currentX = Math.round(startPoint.x + dist * cosAngle); const currentY = Math.round(startPoint.y + dist * sinAngle); const p = {x: currentX, y: currentY}; if (p.x < 0 || p.x >= width || p.y < 0 || p.y >= height || !isPointInAnalysisArea(p) || isPointInExclusionZone(p)) break; const brightness = (data[(p.y * width + p.x) * 4] + data[(p.y * width + p.x) * 4 + 1] + data[(p.y * width + p.x) * 4 + 2]) / 3; const adaptiveThreshold = threshold * 0.5 * Math.max(0.2, 1 - (dist / 800)); if (brightness > adaptiveThreshold) { consecutiveDarkPixels = 0; path.push(p); } else { consecutiveDarkPixels++; if (consecutiveDarkPixels > maxDarkPixels) break; } } const totalLength = Math.hypot(path[path.length-1].x - startPoint.x, path[path.length-1].y - startPoint.y) / scale; if (totalLength >= minLength && path.length >= 3) { const endPoint = path[path.length - 1]; neurites.push({ startpoint: startPoint, endpoint: endPoint, length: totalLength, path: path }); } } return neurites; }
        function calculateDistanceFromMidline(point) { if (!midline || midline.length !== 2) return 0; const [p1, p2] = midline; const lineLength = Math.hypot(p2.x - p1.x, p2.y - p1.y); return lineLength === 0 ? 0 : Math.abs((p2.y - p1.y) * point.x - (p2.x - p1.x) * point.y + p2.x * p1.y - p2.y * p1.x) / lineLength / scale; }
        function categorizeNeurites() { const counts = {'0-200': 0, '200-400': 0, '400-600': 0, '600-800': 0, '800+': 0}; detectedNeurites.forEach(n => { const d = n.distanceFromMidline; if (d >= 0) counts['0-200']++; if (d >= 200) counts['200-400']++; if (d >= 400) counts['400-600']++; if (d >= 600) counts['600-800']++; if (d >= 800) counts['800+']++; }); updateCounters(counts); }
        function updateCounters(counts) { document.getElementById('count_0_200').textContent = counts['0-200']; document.getElementById('count_200_400').textContent = counts['200-400']; document.getElementById('count_400_600').textContent = counts['400-600']; document.getElementById('count_600_800').textContent = counts['600-800']; document.getElementById('count_800_plus').textContent = counts['800+']; }
        function updateRegenerationDisplay() { const total = detectedNeurites.length; const display = document.getElementById('regenDisplay'); if (total === 0) { display.style.display = 'none'; return; } document.getElementById('mainRegenPercentage').textContent = total; document.getElementById('regenDetails').textContent = `neurites detected on ${selectedSide} side`; display.style.display = 'block'; }
        function resetCounters() { ['0_200', '200_400', '400_600', '600_800', '800_plus'].forEach(r => document.getElementById(`count_${r}`).textContent = '0'); }
        function clearCanvas() { if (confirm('This will clear all analysis data. Continue?')) { resetAnalysis(); if (originalImage) { applyImageAdjustments(); } else { ctx.clearRect(0,0,canvas.width,canvas.height); } } }
        function saveNeuriteImage() { try { const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-'); const filename = `neurite_labeled_image_${selectedSide}_side_${timestamp}.png`; canvas.toBlob((blob) => { const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); }, 'image/png'); } catch (error) { alert('Error saving image: ' + error.message); } }
        function exportToCSV() { if (detectedNeurites.length === 0) return alert('No neurites detected.'); const header = 'Neurite_ID,Length_um,Distance_From_Midline_um,Side,Start_X,Start_Y,End_X,End_Y,Manual\n'; const rows = detectedNeurites.map((n, i) => [i + 1, n.length.toFixed(2), n.distanceFromMidline.toFixed(2), selectedSide, n.startpoint.x.toFixed(1), n.startpoint.y.toFixed(1), n.endpoint.x.toFixed(1), n.endpoint.y.toFixed(1), n.manual ? 'Yes' : 'No'].join(',')); const csv = header + rows.join('\n'); const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `neurite_analysis_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.csv`; document.body.appendChild(link); link.click(); document.body.removeChild(link); }
        
        function analyzeResults(shouldScroll = true) {
            if (detectedNeurites.length === 0) {
                document.getElementById('resultsSection').style.display = 'none';
                return;
            }
            const totalNeurites = detectedNeurites.length;
            const longestNeurite = totalNeurites > 0 ? Math.max(...detectedNeurites.map(n => n.distanceFromMidline)).toFixed(0) : 0;
            const averageLength = totalNeurites > 0 ? (detectedNeurites.reduce((sum, n) => sum + n.distanceFromMidline, 0) / totalNeurites).toFixed(0) : 0;
            const actualCounts = {'0-200': 0, '200-400': 0, '400-600': 0, '600-800': 0, '800+': 0};
            detectedNeurites.forEach(n => { const d = n.distanceFromMidline; if (d <= 200) actualCounts['0-200']++; else if (d <= 400) actualCounts['200-400']++; else if (d <= 600) actualCounts['400-600']++; else if (d <= 800) actualCounts['600-800']++; else actualCounts['800+']++; });
            document.getElementById('totalNeurites').textContent = totalNeurites;
            document.getElementById('longestNeurite').textContent = longestNeurite + ' μm';
            document.getElementById('averageLength').textContent = averageLength + ' μm';
            createComparisonChart(actualCounts);
            generateDetailedResults(actualCounts, totalNeurites);
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.style.display = 'block';
            if(shouldScroll) resultsSection.scrollIntoView({ behavior: 'smooth' });
        }
        
        function generateDetailedResults(counts, totalNeurites) {
            const manualCount = detectedNeurites.filter(n => n.manual).length;
            document.getElementById('detailedResults').innerHTML = `<h3>Detailed Analysis Report</h3><p><strong>Total Neurites (Auto + Manual):</strong> ${totalNeurites} (${totalNeurites - manualCount} auto, ${manualCount} manual)</p><h4>Distance Distribution (from Midline)</h4><table class="result-table"><thead><tr><th>Distance Range</th><th>Count</th><th>Percentage</th></tr></thead><tbody>${Object.entries(counts).map(([range, count]) => `<tr><td>${range.replace('-', ' - ')} μm</td><td>${count}</td><td>${totalNeurites > 0 ? (count / totalNeurites * 100).toFixed(1) : 0}%</td></tr>`).join('')}</tbody></table>`;
        }
        
        function createComparisonChart(counts) {
            const chartCtx = document.getElementById('comparisonChart').getContext('2d');
            if (window.comparisonChart && typeof window.comparisonChart.destroy === 'function') {
                window.comparisonChart.destroy();
            }
            window.comparisonChart = new Chart(chartCtx, { type: 'bar', data: { labels: ['0-200 μm', '200-400 μm', '400-600 μm', '600-800 μm', '>800 μm'], datasets: [{ label: `${selectedSide.charAt(0).toUpperCase() + selectedSide.slice(1)} Side Neurites`, data: Object.values(counts), backgroundColor: ['rgba(0, 255, 0, 0.8)','rgba(255, 255, 0, 0.8)','rgba(255, 140, 0, 0.8)','rgba(255, 69, 0, 0.8)','rgba(255, 0, 0, 0.8)'], borderColor: ['rgba(0, 255, 0, 1)','rgba(255, 255, 0, 1)','rgba(255, 140, 0, 1)','rgba(255, 69, 0, 1)','rgba(255, 0, 0, 1)'], borderWidth: 2 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: `Neurite Distribution by Distance`, font: { size: 16, weight: 'bold' } } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'Number of Neurites' } }, x: { title: { display: true, text: 'Distance from Midline (μm)' } } } } });
        }
        
        function showProcessing(show) { document.getElementById('processingOverlay').style.display = show ? 'flex' : 'none'; if (!show) document.getElementById('progressFill').style.width = '0%'; }
        function updateProgress(percent) { document.getElementById('progressFill').style.width = percent + '%'; }
        function updateStatus(message) { document.getElementById('statusBar').textContent = message; }

        // TIFF Modal Functions
        function showTiffModal(file) {
            // Update file information
            document.getElementById('tiffFileName').textContent = file.name;
            document.getElementById('tiffFileSize').textContent = (file.size / (1024 * 1024)).toFixed(1) + ' MB';
            
            // Show modal
            document.getElementById('tiffModal').style.display = 'flex';
            
            // Clear the file input so user can select the same file again after conversion
            document.getElementById('imageInput').value = '';
            document.getElementById('newImageInput').value = '';
        }

        function closeTiffModal() {
            document.getElementById('tiffModal').style.display = 'none';
        }

        // Close modal when clicking outside of it
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('tiffModal');
            if (event.target === modal) {
                closeTiffModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeTiffModal();
            }
        });

        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>